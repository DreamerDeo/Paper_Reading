



# 赛尔笔记|Text2SQL任务介绍

## 作者：窦隆绪、潘名扬、乔振浩

## 任务介绍

语义分解（semantic parsing）是NLP中很重要的一项任务，它要求系统不仅能理解自然语言描述同时还需要产生有意义的、可执行的表达式，例如lambda逻辑表达式、SQL语句或者程序代码。随着深度学习模型的进步，seq2seq模型已经能够在较复杂的数据集例如ATIS、Geoquery上达到80%的精确匹配。

Text-to-SQL任务是指：在指定数据库（或表）的前提下，由用户的提问生成相应的SQL查询语句。用户的提问可以是上下文无关的，例如：

![image-20191219143859554](/Users/longxud/Library/Application Support/typora-user-images/image-20191219143859554.png)

也可以是上下文关联的：

​	![image-20191219144423766](/Users/longxud/Library/Application Support/typora-user-images/image-20191219144423766.png)

问题定义：给定训练集![img](file:////Users/longxud/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.jpg)，xk代表问题，yk代表其对应的SQL语句，sk代表对应数据库的表格信息。需要注意的是，预测时所用到的表格信息S在训练时并不会被看到。表格信息S包括1）该数据库下所有的表格2）每个表格每一列的信息3）所有表格主外键的对应信息。

在本篇文章中，我们首先会对SQL生成的相关数据集按照时间顺序和问题场景进行介绍。之后我们会着重介绍SPIDER（上下文无关、跨领域）数据集上的相关模型。

 

##  相关数据集介绍

大多数之前的工作都使用单一的数据库进行训练和输出，并不要求模型有跨模型推断的能力。也就是说测试集和训练集用到的数据库是同一个，在实际的应用场景下不具有足够的泛化性。s

![image-20191219143958919](/Users/longxud/Library/Application Support/typora-user-images/image-20191219143958919.png)

#### 1.ATIS

ATIS（Air Travel Information System），是关于航班信息的、由用户提问生成SQL语句的单一领域、上下文相关的数据集，采用了BIO标注的方式来标识问句中所包含的的表名和查询条件等。

#### 2.GeoQuery

是与地理区域相关的，单一领域、上下文无关的数据集。特点：按照问句所表达的含义进行分组，每一组表示同一类查询，每组提供几个SQL语句。

####  3.SequentialQA

SequentialQA是跨领域的，上下文相关的数据集。对于每一个表，给数据集给出了三组上下文相关的提问，并给出了对应的查询结果（没有直接给出SQL语句）。 

#### 4.WikiSQL

WikiSQL是跨领域的，上下文无关的数据集。来源于英文维基百科，数据规模较大。但是SQL语句结构较为简单，不需要进行选取表的操作，Where子句的条件使用and连接。

#### 5.Spider

Spider是跨领域的，上下文无关的数据集。领域比较丰富（拥有来自138个领域的200多个数据库），并且训练集、测试集中出现的数据库不重合。SQL语句更为复杂，包含orderBy、union、except、groupBy、intersect、limit、having 关键字，以及嵌套查询等。并且该数据集依据SQL语句的复杂程度，将数据分为了四个难度等级。

#### 6.Sparc

SParC是跨领域的，上下文相关的数据集。数据库基于Spider，并且模拟了用户进行数据库查询的过程：用户通过若干条相关的提问最后达到一个最终查询目的。

 

不同数据集对比：

| 数据集       | 是否上下文相关 | 基于表/  数据库 | 标注类型 | 是否跨领域 |
| ------------ | -------------- | --------------- | -------- | ---------- |
| ATIS         | 是             | 数据库          | SQL      | 否         |
| GeoQuery     | 否             | 数据库          | SQL      | 否         |
| SequentialQA | 是             | 表              | 查询结果 | 是         |
| WikiSQL      | 否             | 表              | SQL      | 是         |
| Spider       | 否             | 数据库          | SQL      | 是         |
| SParC        | 是             | 数据库          | SQL      | 是         |

 

## 主流工作

我们将模型分为上下文无关（1-8），上下文相关（9-10）两种类型。

#### 1.Pointer Network

Text-to-SQL任务可以看作是一个Seq2seq任务，由自然语言句子生成SQL语句。这一任务在80年代就有人提出并进行研究，早期的工作主要针对特定的数据库，并且对于不同的数据集需要额外的定制。以下列出了近年来一些主要的SQL语句生成任务的模型。

Text-to-SQL不同于一般的Seq2seq（序列到序列）任务，它的目标序列中可能出现的单词是问句、数据库的不同而不同的（只可能出现：SQL关键字、对应数据库中的表名、列名、问句中出现的词）

指针网络很好地解决了这一问题，它是一种seq2seq模型，传统的seq2seq模型的解码器部分所使用的单词表是固定的，即在生成序列中都是从固定的单词表中进行选取。而对于一些问题，输出的单词表是随输入而变化的。利用注意力机制，直接从输入序列中选取单词作为输出。

可以考虑把用户的提问以及目标SQL语句可能出现的其他词作为输入序列，利用指针网络直接从输入序列中选取单词作为输出。输入：列名单词序列；SQL的关键字表；问题的单词序列。编码器部分使用双向LSTM；解码器部分使用双层单向LSTM。在解码器的每一步，与编码器的每一步计算注意力分布，取最大值作为输出，和下一步的输入。

#### 2.Seq2SQL

Pointer Network虽然一定程度上解决了这一问题，但是它并没有利用到SQL语句固有的语法结构。于是提出了Seq2SQL，将生成的SQL语句分为三个部分： 聚合操作：（SUM、COUNT、MIN、MAX等）、SELECT：选取列、WHERE：查询条件。每一部分使用不同的方法进行计算

SELECT与聚合操作，均采用了注意力机制进行分类。WHERE子句可以利用前面介绍的Pointer Network进行训练，但是对于很多查询来说，WHERE子句的写法并不是唯一的，例如：

SELECT name FROM insurance WHERE age > 18 AND gender = "male";

SELECT name FROM insurance WHERE gender = "male" AND age > 18;

这可能导致原本正确的输出被判断为错误的。于是作者提出利用强化学习基于查询结果来进行优化。在解码器部分，对可能的输出进行采样，产生若干个SQL语句，每一句表示为y=[y1,y2...yT]，用打分函数对每一句进行打分：

![img](file:////Users/longxud/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image006.jpg)

#### 3.SQLNet

为了解决Seq2SQL使用强化学习效果不明显的问题，Xu et al.提出了SQLNet：将SQL语句分成SELECT和WHERE两个部分，每个部分设置了几个空位，只需向空位中填入相应的符号即可。 

![img](file:////Users/longxud/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image007.jpg)

 

SELECT子句部分与Seq2SQL类似，不同地方在于WHERE子句，它使用了一种sequence-to-set（由序列生成集合）机制，用于选取目标SQL语句中的WHERE子句可能出现的列。对于表中的每一列给出一个概率。之后计算出WHERE子句中的条件个数k，然后选取概率最高的前k个列。最后通过注意力机制进行分类得到操作符和条件值。

 

#### 4.TypeSQL

该模型基于SQLNet，使用模版填充的方法生成SQL语句。为了更好地建模文本中出现的罕见实体和数字，TypeSQL显式地赋予每个单词类型。除此之外，通过利用数据库中的信息，模型取得了更好的结果，但需要注意隐私问题。

类型识别过程：

将问句分割为长度2-6gram，并搜索数据库表、列定义。对于匹配成功的部分赋值column类型赋予数字、日期四种类型：INTEGER、FLOAT、DATE、YEAR。对于命名实体，通过搜索FREEBASE，确定5种类型：PERSON，PLACE，COUNTREY，ORGANIZATION，SPORT。这五种类型包括了大部分实体类型。当可以访问数据库内容时，进一步将匹配到的实体标记为具体列名（而不只是column类型）

SQLNet为模版中的每一种成分设定了单独的模型；TypeSQL对此进行了改进，对于相似的成分，例如$SELECT_COL 和$COND_COL以及#COND（条件数），这些信息间有依赖关系，通过合并为了单一模型，可以更好建模。TypeSQL使用3个独立模型来预测模版填充值：

MODEL_COL：$SELECT_COL，$COND#，$COND_COL

MODEL_AGG：$AGG

MODEL_OPVAL：$OP, $COND_VAL

 

#### 5.SyntaxSQLNet

相比于之前decoder输出一段线性的文本，该工作将解码的过程引入了结构性信息，即解码的对象为SQL语句构成的树结构。（+14.8%）

![image-20191219143846390](/Users/longxud/Library/Application Support/typora-user-images/image-20191219143846390.png)

该工作将SQL语句的预测分解为9个模块，每个模块对应了SQL语句中的一种成分。解码时由预定义的SQL文法确定这9个模块的调用顺序，从而引入结构信息。树的生成顺序为深度优先。分解出的9个模块有：

IUEN模块：预测INTERCEPT、UNION、EXCEPT、NONE（嵌套查询相关）

KW模块：预测WHERE、GROUP BY、ORDER BY、SELECT关键字

COL模块：预测列名

OP模块：预测>、<、=、LIKE等运算符

AGG模块：预测MAX、MIN、SUM等聚合函数

Root/Terminal模块：预测子查询或终结符

Module模块：预测子查询或终结符

AND/OR模块：预测条件表达式间的关系

DESC/ASC/LIMIT模块：预测与ORDER BY相关联的关键字

HAVING模块：预测与GROUP BY相关的Having从句

 

该工作同时提供了一种针对text2sql任务的数据增强方法，生成跨领域、更多样的训练数据。（+7.5%）具体做法为：对SPIDER中的每条数据，将值和列名信息除去，得到一个模版； 对处理后的SQL模版进行聚类，通过规则去除比较简单的模版，并依据模板出现的频率，挑选50个复杂SQL模板； 人工核对SQL-问句对，确保SQL模板中每个槽在问句中都有对应类型的信息。

得到一一对应的模板后，应用于WikiSQL数据库：首先随机挑选10个模板，然后从库中选择相同类型的列，最后用列名和值填充SQL模板和问句模板。通过该方法，作者最终在18000的WikiSQL数据库上得到了新的98000组训练数据，同时在训练的时候也利用了WikiSQL数据集原有的训练数据。

#### 6.IRNet

![image-20191219144146486](/Users/longxud/Library/Application Support/typora-user-images/image-20191219144146486.png)

![image-20191219144206632](/Users/longxud/Library/Application Support/typora-user-images/image-20191219144206632.png)

#### 7.Global-GNN

![image-20191219144100644](/Users/longxud/Library/Application Support/typora-user-images/image-20191219144100644.png) 



![image-20191219144115254](/Users/longxud/Library/Application Support/typora-user-images/image-20191219144115254.png)

#### 8.RAT-SQL

### ![image-20191219143718465](/Users/longxud/Library/Application Support/typora-user-images/image-20191219143718465.png)



![image-20191219143756785](/Users/longxud/Library/Application Support/typora-user-images/image-20191219143756785.png)

#### 9.CD-Seq2Seq

模型在SparC数据集一文中做为BaseLine模型提出，引入了上下文信息。该模型由用于ATIS数据集的模型[14]适配而来。对于上下文信息，该工作采用了Turn-level history encoder来编码轮次信息。具体来说，

![img](file:////Users/longxud/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image011.jpg)

![img](file:////Users/longxud/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image013.jpg)

LSTM_E编码当前语句，![img](file:////Users/longxud/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image015.jpg)为对应词向量；LSTM_I编码对话历史信息，将每一轮问题LSTM编码最后状态做为该轮次的信息传递给下一轮。通过这种方法，使对话信息流动在轮次间流动，而计算开销不至于太高（相较于拼接全部对话历史）。

 

#### 11.EditSQL

EditSQL的提出是根据上下文相关text2sql任务中一个现象：相邻问句、SQL语句间有依赖和重叠关系。该工作通过修改前序生成的SQL（Query Edinting）来提高生成质量。

数据集上的实验验证了该想法，结果如图：

![img](file:////Users/longxud/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image017.jpg)

随着轮数增加，用户的问题越来越复杂，对应SQL语句长度也随着增加。但由于与前轮的SQL有所重叠，需要插入的新词依然保持较低水平。

Query Editing机制与Copy机制类似，在解码第K步，选择从已生成的SQL中的token或新生成一个新关键词\列名。从结果上看，得益于出色的Encoder设计和Query Editing机制，EditSQL相较于CD-Seq2Seq模型在Question Match 和Interaction Match上分别提升了10%、6%准确度。

 

## 总结

 

### 相关引用：

1. Seq2sql: Generating structured queries from natural language using reinforcement learning

2. Towards Complex Text-to-SQL in Cross-Domain Database with Intermediate Representation

3. SParC: Cross-Domain Semantic Parsing in Context

4. CoSQL: A Conversational Text-to-SQL Challenge Towards Cross-Domain Natural Language Interfaces to Databases

5. Pointer Networks

6. Neural semantic parsing with type constraints for semi-structured tables

7. SQLNet: Generating Structured Queries From Natural Language Without Reinforcement Learning

8. TypeSQL: Knowledge-based Type-Aware Neural Text-to-SQL Generation

9. SyntaxSQLNet: Syntax Tree Networks for Complex and Cross-DomainText-to-SQL Task

10. Editing-Based SQL Query Generation for Cross-Domain Context-Dependent Questions

11. Towards Complex Text-to-SQL in Cross-Domain Database with Intermediate Representation

12. Global Reasoning over Database Structures for Text-to-SQL Parsing

13. RAT-SQL: Relation-Aware Schema Encoding and Linking for Text-to-SQL Parsers

14. Learning to Map Context-Dependent Sentences to Executable Formal Queries

 

 

 

 

 